# 21. Section intro

# 22. What is a matcher
- Matcher - a function for boolean comparison between actual value and expected value
- responsible for reporting to Jasmine if expectation is True vs False
- search for toBe() method in jasmine.js to see how it works


# 23. toBe
- go to https://jasmine.github.io/api/3.5/global
- === vs ==
- === compares both value and type


# 24. toEqual
- uses "deep equality comparison" per above site
- ensures objects have equal keys and values
- compares any number of values
- "objects are compared by reference"
- also uses strict comparison ===
- create expectation that it 'has constructor' DON'TGETTHIS


# 25. toBeTruthy, toBeFalsy
DON'TGETTHIS
- change "has a constructor" to "can be instantiated"


# 26. Negating matchers
- not. before the matcher


# 27. toBeDefined, toBeUndefined
- "undefined" variable has 3 properties
1. global property
2. primitive - data that is not an object, and has no methods
3. automatically assigned to variables that have just been declared (AND not initialized?)

## toBeUndefined() matcher
[
    expect(result).toBeDefined();

    const calculator = new Calculator();

    expect(calculator.add).toBeDefined();   // or not.toBeUndefined();
    expect(calculator.subtract).not.toBeUndefined();    // or not.toBeUndefined();
    expect(calculator.multiply).not.toBeUndefined();    // or not.toBeUndefined();
    expect(calculator.divide).not.toBeUndefined();      // or not.toBeUndefined();

]

## toBeDefined() matcher instead of .not'ing the toBeUndefined() matcher


# 28. toBeNull
- to declar an intentional absence of a value
[
    let test = null;
]

WHAT'STHEPOINTOFASSOCIATINGOVERWRITINGWITHSETTINGTONULL???

[
    calculator.total = null;
    expect(calculator.total).toBeNull();
]


# 29. toContain
- can be used to find an item in an [array]
- can be used against a [string] to find a [substring]
- above are two common cases for this matcher
- type is an [object]

## revisiting the Calculator constructor
let calculus = new Calculator();
undefined

calculus.constructor
Æ’ Calculator () {
    this.total = 0;
}

calculus.constructor.name
"Calculator"

## above shows how Calculator constructor has a string as the name value; so we can test for a substring of this in [canbeinstantiated] spec
[
    calculator.constructor.name /* Calculator */).toContain("Calcu");
]

# 30. toBeNaN
- global property/scope (NaN: NaN) that represents NaN
- lives in [window] object --> [window.NaN]
- a matcher exists because you cannot compare NaN to NaN, because [NaN == NaN and NaN === NaN] both evaluate to [false]
- to evaluate a true NaN comparison: [Number.isNaN(NaN);]
- since we don't require [number] to be a number in the [multiply] method, we expect the result of passing in a string to be NaN
[
    
]
[
    expect(thing).toBeNaN();
]

# 31. toThrow, toThrowError

# 32. toMatch

# 33. Other matchers

# 34. Match anything

# 35. Custom matchers

# 36. Third party matchers

# 37. Section summary

# 38. Section notes